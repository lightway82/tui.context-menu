tui.util.defineNamespace("fedoc.content", {});
fedoc.content["contextmenu.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview Context menu component\n * @author NHN Ent. FE Development team &lt;dl_javascript@nhnent.com>\n */\nconst util = tui.util;\n\nimport * as core from './core';\nimport tmpl from './contextmenu.hbs';\n\nconst MODALESS = {modaless: true};\n\n/**\n * @typedef ContextMenu~MenuItem\n * @property {string} title - title of menu item\n * @property {string} [command] - string for alternative of using title to command\n * @property {boolean} [separator=false] - set true then this menu will use\n *  separator\n * @property {MenuItem[]} [menu] - you can define submenu recursivly\n */\n\n/**\n * ContextMenu\n */\nexport default class ContextMenu {\n    /**\n     * Constructor\n     * @param {HTMLElement} container - container for placing context menu\n     *  floating layers\n     * @param {object} options - options for context menu\n     *   @param {number} [options.delay=100] - delay for displaying submenu\n     * @example\n     * var menu = new tui.component.ContextMenu(document.querySelector('#fl'));\n     */\n    constructor(container, options = {\n        delay: 130\n    }) {\n        /**\n         * @type {object}\n         */\n        this.options = Object.assign({}, options);\n        /**\n         * @type {HTMLElement}\n         */\n        this.container = container;\n\n        /**\n         * @type {Map}\n         */\n        this.layerMap = new Map();\n\n        /**\n         * @type {FloatingLayer}\n         */\n        this.activeLayer = null;\n\n        /**\n         * @type {boolean}\n         */\n        this.pageScrolled = false;\n\n        /**\n         * @type {function}\n         */\n        this.cloneMouseMoveEvent = null;\n\n        dom.on(document, 'contextmenu', this._onContextMenu, this);\n    }\n\n    /**\n     * Destructor\n     * @api\n     */\n    destroy() {\n        dom.off(document, 'contextmenu', this._onContextMenu, this);\n\n        this._hideContextMenu();\n\n        this.container = this.layerMap = this.activeLayer =\n            this.pageScolled = this.cloneMouseMoveEvent = null;\n    }\n\n    /**\n     * Hide activated context menu and unbind related DOM events\n     * @private\n     */\n    _hideContextMenu() {\n        const layer = this.activeLayer;\n\n        if (!layer) {\n            return;\n        }\n\n        dom.off(layer.container, 'mousemove', this.cloneMouseMoveEvent, this);\n        dom.off(document, 'mousedown', this._onMouseDown, this);\n        dom.off(document, 'click', this._onMouseClick, this);\n        dom.off(document, 'scroll', this._onPageScroll, this);\n\n        layer.hide();\n\n        let hideElement = (menu) => {\n            dom.css(menu, {\n                display: 'none',\n                marginTop: ''\n            });\n        };\n\n        dom.findAll(layer.container, '.js-menu-root').forEach(hideElement);\n        dom.findAll(layer.container, '.js-menu-submenu').forEach(hideElement);\n\n        this.pageScrolled = false;\n        this.activeLayer = this.cloneMouseMoveEvent = null;\n    }\n\n    /**\n     * Mouse down event handler for close context menu\n     * @param {MouseEvent} mouseDownEvent - mouseDown event object\n     * @private\n     */\n    _onMouseDown(mouseDownEvent) {\n        var target = mouseDownEvent.target || mouseDownEvent.srcElement;\n\n        if (!dom.closest(target, '.js-menu-root')) {\n            this._hideContextMenu();\n        }\n    }\n\n    /**\n     * Mouse click event handler for invoking callback when click menu item\n     * @param {MouseEvent} clickEvent - click MouseEvent object\n     * @private\n     */\n    _onMouseClick(clickEvent) {\n        const target = clickEvent.target || clickEvent.srcElement;\n        const title = dom.textContent(target).trim();\n        const command = dom.getData(target, 'command');\n        const container = dom.closest(target, '.floating-layer');\n        const isMenuButton = dom.hasClass(target, 'js-menu-button');\n        const isSeparator = dom.hasClass(target, 'js-menu-separator');\n        const hasSubmenu = dom.hasClass(target, 'js-menu-has-submenu');\n\n        if (!(container &amp;&amp; isMenuButton)) {\n            return;\n        }\n\n        if (isSeparator || hasSubmenu) {\n            return;\n        }\n\n        for (let layer of this.layerMap.values()) {\n            if (container === layer.container) {\n                layer.callback(clickEvent, command || title);\n                this._hideContextMenu();\n\n                return;\n            }\n        }\n    }\n\n    /**\n     * Show menu element without veil browser viewport\n     * @param {HTMLElement} element - menu element\n     * @param {object} [strategy] - methods for handle situations that\n     *  menu veil by browser viewports\n     * @param {object} [initialStyle] - initial style before\n     *  calculating new bound\n     * @private\n     */\n    _showWithoutOverflow(\n        element,\n        strategy = {rightOverflow: core.noop, bottomOverflow: core.noop},\n        initialStyle = {marginTop: '', marginLeft: ''}\n    ) {\n        dom.css(element, 'visibility', 'hidden');\n        dom.css(element, initialStyle);\n        dom.css(element, 'display', 'block');\n\n        const {right: menuRight, bottom: menuBottom} = dom.getRect(element);\n\n        const menuDoc = (element.document || element.ownerDocument).documentElement;\n        const {clientWidth: viewportWidth, clientHeight: viewportHeight} = menuDoc;\n\n        const isRightOverflowed = menuRight > viewportWidth;\n        const isBottomOverflowed = menuBottom > viewportHeight;\n\n        if (isRightOverflowed) {\n            strategy.rightOverflow(element, menuRight, viewportWidth);\n        }\n\n        if (isBottomOverflowed) {\n            strategy.bottomOverflow(element, menuBottom, viewportHeight);\n        }\n\n        dom.css(element, 'visibility', '');\n    }\n\n    /**\n     * Show root menu element\n     * @param {number} left - left pixel position\n     * @param {number} top - top pixel position\n     * @private\n     */\n    _showRootMenu(left, top) {\n        const layer = this.activeLayer;\n\n        if (!layer) {\n            return;\n        }\n\n        const rootMenuElement = dom.find(layer.container, '.js-menu-root');\n\n        layer.setBound({left, top});\n        layer.show();\n\n        this._showWithoutOverflow(\n            rootMenuElement,\n            {\n                rightOverflow: function(el, right, viewportWidth) {\n                    dom.css(el, 'marginLeft', `${viewportWidth - right}px`);\n                },\n                bottomOverflow: function(el, bottom, viewportHeight) {\n                    dom.css(el, 'marginTop', `${viewportHeight - bottom}px`);\n                }\n            }\n        );\n    }\n\n    /**\n     * Show sub menu element\n     * @param {HTMLElement} element - submenu root element\n     * @private\n     */\n    _showSubMenu(element) {\n        this._showWithoutOverflow(\n            element,\n            {\n                rightOverflow: (el, right, viewportWidth) => {\n                    dom.css(el, 'marginLeft',\n                        `${(viewportWidth - right) + el.clientWidth}px`);\n                },\n                bottomOverflow: (el, bottom, viewportHeight) => {\n                    dom.css(el, 'marginTop', `${viewportHeight - bottom}px`);\n                }\n            },\n            {\n                marginTop: '',\n                marginLeft: '100%'\n            }\n        );\n    }\n\n    /**\n     * Refresh all submenu element\n     *\n     * Hide elements that no related with mouse event and show others\n     * @param {HTMLElement} layerOnCursor - layer element on cursor\n     * @private\n     */\n    _refreshMenuDisplay(layerOnCursor) {\n        const container = this.activeLayer.container;\n        const allSubmenus = dom.findAll(container, '.js-menu-submenu');\n        const layersUntilRoot = [];\n\n        while (layerOnCursor &amp;&amp; container !== layerOnCursor) {\n            if (dom.hasClass(layerOnCursor, 'js-menu-submenu')) {\n                layersUntilRoot.push(layerOnCursor);\n            }\n\n            layerOnCursor = layerOnCursor.parentNode;\n        }\n\n        allSubmenus.forEach(menuElement => {\n            if (layersUntilRoot.indexOf(menuElement) &lt; 0) {\n                dom.css(menuElement, 'display', 'none');\n            }\n        });\n\n        layersUntilRoot.forEach(util.bind(this._showSubMenu, this));\n    }\n\n    /**\n     * Mouse move event handler for reveal context menus\n     * @param {MouseEvent} mouseMoveEvent - mouse move event object\n     * @private\n     */\n    _onMouseMove(mouseMoveEvent) {\n        if (this.pageScrolled) {\n            this.pageScrolled = false;\n\n            return;\n        }\n\n        const target = mouseMoveEvent.target || mouseMoveEvent.srcElement;\n        const activeLayer = this.activeLayer;\n\n        if (!(activeLayer &amp;&amp; dom.closest(target, '.js-menu-root'))) {\n            return;\n        }\n\n        let layerOnCursor;\n\n        if (dom.hasClass(target, 'js-menu-has-submenu')) {\n            layerOnCursor = dom.find(target.parentNode, '.js-menu-submenu');\n        } else {\n            layerOnCursor = dom.closest(target, '.js-menu-submenu');\n        }\n\n        this._refreshMenuDisplay(layerOnCursor);\n    }\n\n    /**\n     * Scroll handle for prevent break position after scrolling\n     * @private\n     */\n    _onPageScroll() {\n        this.pageScrolled = true;\n    }\n\n    /**\n     * Event handler\n     * @param {MouseEvent} clickEvent - mouse event object\n     * @private\n     */\n    _onContextMenu(clickEvent) {\n        const opt = this.options;\n\n        let target = clickEvent.target || clickEvent.srcElement;\n        let relatedLayer;\n\n        while (target.parentNode) {\n            let findElement = this.layerMap.get(target);\n\n            if (findElement) {\n                relatedLayer = findElement;\n                break;\n            }\n\n            target = target.parentNode;\n        }\n\n        if (!relatedLayer) {\n            return;\n        }\n\n        dom.preventDefault(clickEvent);\n\n        this.activeLayer = relatedLayer;\n\n        const left = clickEvent.clientX;\n        const top = clickEvent.clientY;\n        const debouncedMouseMove = util.debounce(util.bind(this._onMouseMove, this), opt.delay);\n\n        this.cloneMouseMoveEvent = function(mouseMoveEvent) {\n            const virtualMouseEvent = {\n                target: (mouseMoveEvent.target || mouseMoveEvent.srcElement)\n            };\n\n            debouncedMouseMove(virtualMouseEvent);\n        };\n\n        this._showRootMenu(left, top);\n\n        dom.on(relatedLayer.container, 'mousemove', this.cloneMouseMoveEvent, this);\n        dom.on(document, 'mousedown', this._onMouseDown, this);\n        dom.on(document, 'click', this._onMouseClick, this);\n        dom.on(document, 'scroll', this._onPageScroll, this);\n    }\n\n    /**\n     * Register context menu\n     * @param {string} selector - css selector for displaying contextmenu at\n     *  secondary mouse button click\n     * @param {function} callback - callback for each menu item clicked\n     * @param {MenuItem[]} menuItems - menu item schema\n     * @api\n     */\n    register(selector, callback, menuItems) {\n        const target = dom.find(selector);\n\n        if (!target) {\n            return;\n        }\n\n        const layer = new tui.component.FloatingLayer(this.container, MODALESS);\n\n        layer.callback = callback;\n        layer.setBound({width: 'auto', height: 'auto'});\n        layer.setContent(tmpl(menuItems));\n\n        this.layerMap.set(target, layer);\n    }\n\n    /**\n     * Unregister context menu\n     * @param {string} selector - css selector used for register context menu\n     * @returns {boolean} whether unregister is successful?\n     * @api\n     */\n    unregister(selector) {\n        const layerMap = this.layerMap;\n        const target = dom.find(selector);\n\n        if (!target) {\n            return false;\n        }\n\n        const layer = layerMap.get(target);\n\n        if (!layer) {\n            return false;\n        }\n\n        layer.destroy();\n\n        layerMap.delete(target);\n\n        return true;\n    }\n}\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"